/*
Copyright (C) 2018 Adrian Michel
http://www.amichel.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#pragma once

#include <enum.h>

#include "document.h"
#include <charthandler.h>
#include "tradery.h"

class RestartingNotWaitingSessionException {};

class StartingActiveSessionException {};

class SymbolsSourceNotAvailableException {};

class Running {
 public:
  virtual ~Running() {}

  virtual bool isRunning() const = 0;
};

class TASessionException {
 private:
  const std::string _message;

 public:
  TASessionException(const std::string& message) : _message(message) {}

  const std::string& message() const { return _message; }
};

struct SessionParams {
 public:
  // contains
  PositionsVector& _pos;

  // moves all positions in the first element of the vector
  // now the first element has all the positions generated by all systems,
  // ready for position sizing and stats processing
  PositionsContainer* populateAllPositions() {
    return _pos.populateAllPositions();
  }

  SessionParams(PositionsVector& pos) : _pos(pos) {}

  size_t posCount() const { return _pos.count(); }

  void sendPositions(PositionHandler& pr, bool& cancel) {
    // now send all the generated trades to the list box, if enabled

    for (PositionsVector::const_iterator i = _pos.begin();
         i != _pos.end() && !cancel; i++) {
      const PositionsContainer& pc = **i;

      pc.forEachConst(pr);
    }
  }

  void clear() { _pos.clear(); }

  bool exportPositionsCSV(std::ostream& os) const {
    PositionsContainerToCSV(_pos, os);

    return true;
  }

  PositionsVector& getPositionsVector() { return _pos; }
};

// counts something per run and per session
class Counter {
  unsigned long _runCount;
  unsigned long _sessionCount;
  mutable Mutex _mx;

 public:
  Counter() : _runCount(0), _sessionCount(0) {}
  unsigned long runCount() const {
    Lock lock(_mx);
    return _runCount;
  }
  unsigned long sessionCount() const {
    Lock lock(_mx);
    return _sessionCount;
  }
  void reset() {
    Lock lock(_mx);
    _runCount = _sessionCount = 0;
  }
  void resetRun() {
    Lock lock(_mx);
    _runCount = 0;
  }
  void increment() {
    Lock lock(_mx);
    _sessionCount++;
    _runCount++;
  }
  //	void increment( unsigned long inc ) { Lock lock( _mx ); _sessionCount +=
  // inc; _runCount += inc; }
};

class RunsCounter : protected ::Counter, public RunnableRunInfoHandler {
 private:
  RunnableRunInfoHandler* _receiver;

 public:
  RunsCounter() : _receiver(0) {}

  void setRunnableStatusReceiver(RunnableRunInfoHandler* receiver) {
    ASSERT(receiver != 0);
    _receiver = receiver;
  }
  unsigned long currentRunsCount() const { return __super::runCount(); }
  unsigned long sessionRunsCount() const { return __super::sessionCount(); }
  virtual void status(const RunnableRunInfo& status) {
    ASSERT(_receiver != 0);
    __super::increment();
    _receiver->status(status);
  }
};

class TAErrorSink : public ErrorEventSink, protected ::Counter {
 private:
  ErrorEventSink* _sink;
  mutable Mutex _mx;

 public:
  TAErrorSink() : _sink(0) {}
  virtual ~TAErrorSink() {}

 public:
  void setErrorSink(ErrorEventSink* sink) {
    Lock lock(_mx);
    _sink = sink;
  }

  //////////////////////////////////////////////////////
  // ErrorEventSink methods
  virtual void push(const ErrorEvent& event) {
    Lock lock(_mx);
    __super::increment();
    ASSERT(_sink != 0);
    _sink->push(event);
  }

  unsigned long runErrorCount() const { return __super::runCount(); }
  unsigned long sessionErrorCount() const { return __super::sessionCount(); }

  // unused methods
  virtual void pop() {}
  virtual const ErrorEvent* front() const { return 0; }
  virtual bool empty() const { return true; }
  virtual size_t size() const { return 0; }
};

// a signal handler used inside the trading app GUI to count signals, dispatch
// signals etc.
class TASignalHandler : public SignalHandler,
                        public ::Counter,
                        public SessionEventHandlerDelegator {
 private:
  std::map<UniqueId, SignalHandler*> _signalHandlers;
  mutable Mutex _mx;

 public:
  TASignalHandler()
      : SignalHandler(Info("C2CE160D-55E3-44a3-A7AE-EC751B1DA8DF", "", "")) {}

  ~TASignalHandler() {
    // there shuoldn't be any signal handlers upon destruction
    assert(_signalHandlers.size() == 0);
  }
  unsigned long runSignalCount() const { return __super::runCount(); }
  unsigned long sessionSignalCount() const { return __super::sessionCount(); }

  virtual void signal(SignalPtr signal) {
    Lock lock(_mx);
    __super::increment();
    for (std::map<UniqueId, SignalHandler*>::iterator i =
             _signalHandlers.begin();
         i != _signalHandlers.end(); i++)
      i->second->signal(signal);
  }

  void addSignalHandler(SignalHandler* signalHandler) {
    Lock lock(_mx);
    _signalHandlers.insert(std::map<UniqueId, SignalHandler*>::value_type(
        signalHandler->id(), signalHandler));
    SessionEventHandlerDelegator::add(signalHandler);
  }

  void removeSignalHandler(const UniqueId& id) {
    Lock lock(_mx);
    assert(_signalHandlers.find(id) != _signalHandlers.end());
    SessionEventHandlerDelegator::remove(_signalHandlers[id]);
    _signalHandlers.erase(id);
  }

  virtual void sessionStarted(SessionInfo& so) {
    SessionEventHandlerDelegator::sessionStarted(so);
  }

  virtual void sessionEnded(PositionsContainer& positions) {
    SessionEventHandlerDelegator::sessionEnded(positions);
  }

  virtual void sessionCanceled() {
    SessionEventHandlerDelegator::sessionCanceled();
  }

  virtual void runStarted() { SessionEventHandlerDelegator::runStarted(); }

  virtual void runCanceled() { SessionEventHandlerDelegator::runCanceled(); }

  virtual void runEnded() { SessionEventHandlerDelegator::runEnded(); }
};

class SessionRunTimer {
 private:
  mutable Timer _run;
  mutable Timer _session;

 public:
  double runElapsed() const { return _run.elapsed(); }
  double sessionElapsed() const { return _session.elapsed(); }
  void reset() {
    _run.restart();
    _session.restart();
  }
  void stop() {
    _run.stop();
    _session.stop();
  }
  void stopRun() { _run.stop(); }
  void resetRun() { _run.restart(); }
};

template <class T, Node::NodeType Type>
class ConfigContextBase {
 private:
  std::auto_ptr<PluginInstance<T> > _plugin;
  ManagedPtr<T> _config;
  int _count;

 public:
  ConfigContextBase() : _plugin(0), _count(0) {}

  virtual ~ConfigContextBase() {
    if (_count == 1) release();
    assert(_count = 0);
  }

  void create(const UniqueId& id) {
    assert(_config == 0 || _config->id() == id);

    if (_count == 0) {
      const UniqueId* parent = pluginTree.parent(id);
      // todo: handle this case too
      ASSERT(parent != 0);
      _plugin = pluginTree.getPlugin<T, Type>(*parent);
      _config = (*_plugin)->get(id);
      assert(config != 0);
    }
    _count++;
  }

  void set(std::auto_ptr<PluginInstance<T> > plugin, ManagedPtr<T> config) {
    assert(_count == 0);
    assert(_plugin.get() == 0);
    assert(_config == 0);

    _plugin = pi;
    _config = ds;
    _count++;
  }

  void release() {
    _count--;
    assert(_count >= 0);
    if (_count == 0) {
      if (_plugin.get() != 0) {
        assert(_config);
        _config.release();
        delete _plugin.release();
      }
    }
  }
};

class DataSourceContext : public SessionEventHandlerDelegator {
  OBJ_COUNTER(DataSourceContext)
 private:
  boost::shared_ptr<PluginInstance<DataSource> > _dataSourcePlugin;
  ManagedPtr<DataSource> _dataSource;
  int _count;
  const PluginTree& pluginTree;

 public:
  DataSourceContext(const PluginTree& pluginTree)
      : _count(0), pluginTree(pluginTree) {}

  ~DataSourceContext() {
    // if an exception is thrown, the count may be one, in which case release
    if (_count == 1) release();
    assert(_count == 0);
  }

  DataSource* getDataSource() { return _dataSource.get(); }

  const UniqueId& id() const {
    assert(_dataSource.get() != 0);
    return _dataSource->id();
  }

  void create(const UniqueId& id, const std::vector<std::string>* defStrings) {
    assert(!_dataSource || _dataSource->id() == id);

    if (_count == 0) {
      // we are sure that there are default values for datasource and
      // symbolssource, so the pointers cannot be 0

      try {
        const UniqueId* parent(pluginTree.parent(id));
        // todo: handle this case too
        assert(parent != 0);
        _dataSourcePlugin =
            pluginTree.getPlugin<DataSource, Node::NodeType::DATASOURCE>(
                *parent);
        _dataSource = (*_dataSourcePlugin)->get(id, defStrings);
        SessionEventHandlerDelegator::add(_dataSource.get());
      } catch (const IdNotFoundException& e) {
        std::ostringstream o;

        o << "Data Source " << e.id().toString() << " not found";
        throw TASessionException(o.str());
      } catch (const WrongPluginTypeException& e) {
        throw TASessionException(e.message());
      }
    }
    _count++;
  }

  void set(std::auto_ptr<PluginInstance<DataSource> > pi,
           ManagedPtr<DataSource> ds) {
    assert(_count == 0);
    assert(_dataSourcePlugin.get() == 0);
    assert(!_dataSource);

    _dataSourcePlugin = pi;
    _dataSource = ds;
    _count++;
    SessionEventHandlerDelegator::add(_dataSource.get());
  }

  void release() {
    _count--;
    assert(_count >= 0);
    if (_count == 0) {
      if (_dataSourcePlugin.get() != 0) {
        SessionEventHandlerDelegator::remove(_dataSource.get());
      }
    }
  }
};

class SymbolsSourceContext : public SessionEventHandlerDelegator {
 private:
  std::auto_ptr<PluginInstance<SymbolsSource> > _symbolsSourcePlugin;
  ManagedPtr<SymbolsSource> _symbolsSource;
  int _count;
  const PluginTree& pluginTree;

 public:
  SymbolsSourceContext(const PluginTree& pluginTree)
      : _symbolsSourcePlugin(0), _count(0), pluginTree(pluginTree) {}

  ~SymbolsSourceContext() {
    // if an exception is thrown, the count may be one, in which case release
    if (_count == 1) release();
    assert(_count == 0);
  }

  const UniqueId& id() const {
    assert(_symbolsSource);
    return _symbolsSource->id();
  }

  // returns the number of symbols in the default symbols source
  unsigned __int64 symbolsCount() const
      throw(SymbolsSourceNotAvailableException) {
    if (_symbolsSource)
      return _symbolsSource->size();
    else
      throw SymbolsSourceNotAvailableException();
  }

  void create(
      const UniqueId& id,
      const std::vector<std::string>* createStrings) throw(TASessionException) {
    assert(!_symbolsSource || _symbolsSource->id() == id);

    if (_count == 0) {
      try {
        const UniqueId* parent = pluginTree.parent(id);
        _symbolsSourcePlugin =
            pluginTree.getPlugin<SymbolsSource, Node::NodeType::SYMBOLSSOURCE>(
                *parent);
        _symbolsSource = (*_symbolsSourcePlugin)->get(id, createStrings);
        SessionEventHandlerDelegator::add(_symbolsSource.get());
      } catch (const IdNotFoundException& e) {
        std::ostringstream o;

        o << "Symbols Source " << e.id().toString() << " not found";
        throw TASessionException(o.str());
      } catch (const WrongPluginTypeException& e) {
        throw TASessionException(e.message());
      } catch (const PluginException& e) {
        throw TASessionException(e.message());
      } catch (const SymbolsSourceException& e) {
        throw TASessionException(e.message());
      }
    }
    _count++;
  }

  void set(std::auto_ptr<PluginInstance<SymbolsSource> > pi,
           ManagedPtr<SymbolsSource> ds) {
    assert(_count == 0);
    assert(_symbolsSourcePlugin.get() == 0);
    assert(!_symbolsSource);

    _symbolsSourcePlugin = pi;
    _symbolsSource = ds;
    SessionEventHandlerDelegator::add(_symbolsSource.get());
    _count++;
  }

  void release() {
    _count--;
    assert(_count >= 0);
    if (_count == 0) {
      if (_symbolsSourcePlugin.get() != 0) {
        SessionEventHandlerDelegator::remove(_symbolsSource.get());
        _symbolsSource.reset();
        delete _symbolsSourcePlugin.release();
      }
    }
  }

  tradery::SymbolsIterator* makeIterator() {
    return _symbolsSource->makeIterator();
  }
};

class SignalHandlerContext : public TASignalHandler {
 private:
  std::auto_ptr<PluginInstance<SignalHandler> > _signalHandlerPlugin;
  ManagedPtr<SignalHandler> _signalHandler;
  int _count;
  const PluginTree& pluginTree;

 public:
  SignalHandlerContext(const PluginTree& pluginTree)
      : _signalHandlerPlugin(0), _count(0), pluginTree(pluginTree) {}

  ~SignalHandlerContext() {
    if (_count == 1) release();
    assert(_count == 0);
  }

  void create(const UniqueId& id,
              const std::vector<std::string>* createStrings) {
    assert(!_signalHandler || _signalHandler->id() == id);

    if (_count == 0) {
      try {
        const UniqueId* parent = pluginTree.parent(id);
        // todo: handle this case too
        assert(parent != 0);
        _signalHandlerPlugin =
            pluginTree.getPlugin<SignalHandler, Node::NodeType::SIGNALHANDLER>(
                *parent);
        _signalHandler = (*_signalHandlerPlugin)->get(id, createStrings);
        assert(_signalHandler);
        __super::addSignalHandler(_signalHandler.get());
      } catch (const IdNotFoundException& e) {
        std::ostringstream o;

        o << "Signal Handler " << e.id().toString() << " not found";
        throw TASessionException(o.str());
      } catch (const WrongPluginTypeException& e) {
        throw TASessionException(e.message());
      }
    }
    _count++;
  }

  void set(std::auto_ptr<PluginInstance<SignalHandler> > pi,
           ManagedPtr<SignalHandler> ds) {
    assert(_count == 0);
    assert(_signalHandlerPlugin.get() == 0);
    assert(!_signalHandler);

    _signalHandlerPlugin = pi;
    _signalHandler = ds;
    __super::addSignalHandler(_signalHandler.get());

    _count++;
  }

  void release() {
    _count--;
    assert(_count >= 0);
    if (_count == 0) {
      if (_signalHandlerPlugin.get() != 0) {
        assert(_signalHandler);
        __super::removeSignalHandler(_signalHandler->id());
        _signalHandler.reset();
        delete _signalHandlerPlugin.release();
      }
    }
  }
};

class SessionInfoImpl : public SessionInfo {
 private:
  mutable OutputSink* _os;
  const std::string _sessionName;
  DateTimeRangePtr _range;
  DataSource* _defDataSource;
  tradery::SymbolsIterator* _si;
  const RuntimeParams* _runtimeParams;
  RuntimeStats* _runtimeStats;
  const UniqueId& _sessionId;

 public:
  SessionInfoImpl(const std::string& sessionName, const UniqueId& sessionId,
                  DataSource* defDataSource, DateTimeRangePtr range,
                  tradery::SymbolsIterator* si,
                  const RuntimeParams* runtimeParams,
                  RuntimeStats* runtimeStats, OutputSink* os)
      : _os(os),
        _sessionName(sessionName),
        _range(range),
        _defDataSource(defDataSource),
        _si(si),
        _runtimeParams(runtimeParams),
        _runtimeStats(runtimeStats),
        _sessionId(sessionId) {
    assert(runtimeParams != 0);
    assert(os != 0);
    assert(si != 0);
  }

  /**
   * Returns the session name
   *
   * @return The session name
   */
  const std::string& sessionName() const { return _sessionName; }

  virtual OutputSink& outputSink() const {
    assert(_os != 0);
    return *_os;
  }

  virtual BarsPtr getData(const std::string& symbol) const {
    DataInfo di(_defDataSource, SymbolConstPtr(new Symbol(symbol)));

    try {
      return _defDataSource->getData(&di, _range)->getDataCollection();
    } catch (const exception& e) {
      LOG1(log_error, _sessionId.toString(),
           "exception getting data for symbol \"" << symbol
                                                  << "\": " << e.what());
      return BarsPtr();
    } catch (...) {
      LOG1(log_error, _sessionId.toString(),
           "unknown exception getting data for symbol \"" << symbol);
      return BarsPtr();
    }
  }

  // each plug-in gets its own iterator
  virtual tradery::SymbolsIterator* symbolsIterator() const { return _si; }

  virtual const RuntimeParams* runtimeParams() const { return _runtimeParams; }

  virtual RuntimeStats* runtimeStats() { return _runtimeStats; }
};

typedef ManagedPtr<SessionInfo> SessionInfoPtr;

class TASession : public Running,
                  public RunEventHandler,
                  public TAErrorSink,
                  public SessionRunTimer,
                  public RunsCounter {
 private:
  DataSourceContext _defDataSource;
  SymbolsSourceContext _defSymbolsSource;
  SignalHandlerContext _defSignalHandler;
  std::auto_ptr<PluginInstance<Commission> > _defCommissionPlugin;
  std::auto_ptr<PluginInstance<Slippage> > _defSlippagePlugin;

  chart::ChartManager* _chartManager;

  typedef std::map<UniqueId, ManagedPtr<PluginInstance<Runnable> > >
      RunnablePluginInstances;
  RunnablePluginInstances _runnablePluginInstances;
  typedef std::map<UniqueId, ManagedPtr<DataInfoIterator> > DataIteratorsMap;
  DataIteratorsMap _dataInfoIterators;

  std::vector<ManagedPtr<Runnable> > _runnables;
  std::vector<ManagedPtr<Commission> > _commissions;
  std::vector<ManagedPtr<Slippage> > _slippages;

  bool _sessionEndedReceived;

  RuntimeStats* _rts;

  tradery::Session _session;

  DocumentBase& _document;
  //	SessionEventHandler* _sessionEventHandler;
  // if to repeat when reset
  RuntimeStatus _status;
  mutable Mutex _mx;
  mutable NonRecursiveMutex _mxStatusChange;
  size_t _sessionTradesCount;
  SessionParams* _params;
  OutputSink& _os;
  const UniqueId _shId;
  // the various session info instances must be held on to during the run, as
  // the various plug-ins may need them also, we are creating multiple instances
  // because each of them has a different symbols iterator
  std::vector<SessionInfoPtr> _si;

 private:
  SessionInfoPtr makeSessionInfo(DateTimeRangePtr range) {
    _si.push_back(SessionInfoPtr(new SessionInfoImpl(
        _document.name(), _document.getSessionId(),
        _defDataSource.getDataSource(), range, _defSymbolsSource.makeIterator(),
        &_document.getRuntimeParams(), _rts, &_os)));
    return _si.back();
  }

  // clears the vector that contains all the session info objects
  void clearSessionInfo() {
    _si.clear();
    _sessionEndedReceived = false;
  }

  void setStatusRunning() { setStatus(RUNNING); }

  void setStatusCanceling() { setStatus(CANCELING); }

  void setStatusReady() { setStatus(READY); }

  void setStatus(RuntimeStatus status) {
    LOG1(log_debug, _document.getSessionId().toString(),
         "setting status to " << ToString(_status));
    _status = status;
  }

  void notifySessionStarted(DateTimeRangePtr range) {
    LOG1(log_info, getSessionId().toString(), "begin");
    // clear all session infos
    clearSessionInfo();
    // create new session info objects for all plug-ins
    // the session infos are stored in a vector that is cleared every time a new
    // session starts this way each plug-in has their own instance, but they
    // don't need to manage the lifetime of the object
    _defSignalHandler.sessionStarted(*makeSessionInfo(range));
    _defDataSource.sessionStarted(*makeSessionInfo(range));
    _defSymbolsSource.sessionStarted(*makeSessionInfo(range));

    for (size_t n = 0; n < _runnables.size(); n++)
      _runnables[n]->sessionStarted(*makeSessionInfo(range));
    for (size_t n = 0; n < _commissions.size(); n++)
      _commissions[n]->sessionStarted(*makeSessionInfo(range));
    for (size_t n = 0; n < _slippages.size(); n++)
      _slippages[n]->sessionStarted(*makeSessionInfo(range));

    if (_document.getRuntimeParams().chartsEnabled()) _chartManager->init(_rts);
    LOG1(log_info, getSessionId().toString(), "end");
  }

  void notifySessionEnded() {
    LOG1(log_info, getSessionId().toString(), "begin");
    _sessionEndedReceived = true;

    // we have to serialize the charts here, because they depend on the
    // individual position containers being still valid, the next step
    // (reorganizePositions) will move all positions to the first collection,
    // thus emptying all the others move all positions generated by all systems
    // to the positions collection at the front of the vector containing all the
    // positions collections
    PositionsContainer& pc(*_params->populateAllPositions());

    _defSignalHandler.sessionEnded(pc);
    _defDataSource.sessionEnded(pc);
    _defSymbolsSource.sessionEnded(pc);
    for (size_t n = 0; n < _runnables.size(); n++)
      _runnables[n]->sessionEnded(pc);
    for (size_t n = 0; n < _commissions.size(); n++)
      _commissions[n]->sessionEnded(pc);
    for (size_t n = 0; n < _slippages.size(); n++)
      _slippages[n]->sessionEnded(pc);

    if (_chartManager != 0) _chartManager->serialize();

    LOG1(log_info, getSessionId().toString(), "end");
  }

  void notifySessionCanceled() {
    LOG1(log_info, getSessionId().toString(), "begin");
    _defSignalHandler.sessionCanceled();
    _defDataSource.sessionCanceled();
    _defSymbolsSource.sessionCanceled();
    for (size_t n = 0; n < _runnables.size(); n++)
      _runnables[n]->sessionCanceled();
    for (size_t n = 0; n < _commissions.size(); n++)
      _commissions[n]->sessionCanceled();
    for (size_t n = 0; n < _slippages.size(); n++)
      _slippages[n]->sessionCanceled();
    LOG1(log_info, getSessionId().toString(), "end");
  }

  void notifyRunStarted() {
    LOG1(log_info, getSessionId().toString(), "begin");
    _defSignalHandler.runStarted();
    _defDataSource.runStarted();
    _defSymbolsSource.runStarted();
    for (size_t n = 0; n < _runnables.size(); n++) _runnables[n]->runStarted();
    for (size_t n = 0; n < _commissions.size(); n++)
      _commissions[n]->runStarted();
    for (size_t n = 0; n < _slippages.size(); n++) _slippages[n]->runStarted();
    LOG1(log_info, getSessionId().toString(), "end");
  }

  void notifyRunCanceled() {
    LOG1(log_info, getSessionId().toString(), "begin");
    _defSignalHandler.runCanceled();
    _defDataSource.runCanceled();
    _defSymbolsSource.runCanceled();
    for (size_t n = 0; n < _runnables.size(); n++) _runnables[n]->runCanceled();
    for (size_t n = 0; n < _commissions.size(); n++)
      _commissions[n]->runCanceled();
    for (size_t n = 0; n < _slippages.size(); n++) _slippages[n]->runCanceled();
    LOG1(log_info, getSessionId().toString(), "end");
  }

  void notifyRunEnded() {
    LOG1(log_info, getSessionId().toString(), "begin");
    _defSignalHandler.runEnded();
    _defDataSource.runEnded();
    _defSymbolsSource.runEnded();
    for (size_t n = 0; n < _runnables.size(); n++) _runnables[n]->runEnded();
    for (size_t n = 0; n < _commissions.size(); n++)
      _commissions[n]->runEnded();
    for (size_t n = 0; n < _slippages.size(); n++) _slippages[n]->runEnded();
    LOG1(log_info, getSessionId().toString(), "end");
  }

 public:
  TASession(DocumentBase& document, SignalHandler* signals,
            ErrorEventSink* errorSink, RunnableRunInfoHandler* statusReceiver,
            RuntimeStats* rts, OutputSink& os)
      : _document(document),
        _session(this),
        _status(READY),
        _sessionTradesCount(0),
        _os(os),
        _sessionEndedReceived(false),
        _shId(signals->id()),
        _defDataSource(getGlobalPluginTree()),
        _chartManager(document.chartManager()),
        _rts(rts),
        _defSymbolsSource(getGlobalPluginTree()),
        _defSignalHandler(getGlobalPluginTree()) {
    _defSignalHandler.addSignalHandler(signals);
    TAErrorSink::setErrorSink(errorSink);
    RunsCounter::setRunnableStatusReceiver(statusReceiver);
  }

  ~TASession() { _defSignalHandler.removeSignalHandler(_shId); }

  template <class T>
  void setConfig(std::auto_ptr<PluginInstance<T> > pi, ManagedPtr<T> ds) {
    assert(false);
  }
  template <>
  void setConfig<DataSource>(std::auto_ptr<PluginInstance<DataSource> > pi,
                             ManagedPtr<DataSource> ds) {
    _defDataSource.set(pi, ds);
  }
  template <>
  void setConfig<SymbolsSource>(
      std::auto_ptr<PluginInstance<SymbolsSource> > pi,
      ManagedPtr<SymbolsSource> ds) {
    _defSymbolsSource.set(pi, ds);
  }
  template <>
  void setConfig<SignalHandler>(
      std::auto_ptr<PluginInstance<SignalHandler> > pi,
      ManagedPtr<SignalHandler> ds) {
    _defSignalHandler.set(pi, ds);
  }
  template <class T>
  void releaseConfig() {
    assert(false);
  }
  template <>
  void releaseConfig<DataSource>() {
    _defDataSource.release();
  }
  template <>
  void releaseConfig<SymbolsSource>() {
    _defSymbolsSource.release();
  }
  template <>
  void releaseConfig<SignalHandler>() {
    _defSignalHandler.release();
  }
  unsigned long runSignalCount() const {
    return _defSignalHandler.runSignalCount();
  }
  unsigned long sessionSignalCount() const {
    return _defSignalHandler.sessionCount();
  }
  bool sessionEndedReceived() const { return _sessionEndedReceived; }

  const UniqueId& getSessionId() const { return _document.getSessionId(); }

 private:
  void createRunnablePlugins() {
    LOG1(log_info, getSessionId().toString(), "start");
    try {
      for (const UniqueId* p = _document.getFirstRunnableId(); p != 0;
           p = _document.getNextRunnableId()) {
        LOG1(log_debug, getSessionId().toString(),
             "creating plugin for runnable id: " << p->toString());
        ASSERT(p != 0);
        const UniqueId* parent = _document.getSessionPluginTree().parent(*p);
        if (parent == 0) {
          std::ostringstream os;
          LOG1(log_error, getSessionId().toString(),
               "could not find plugin for runnable id: " << p->toString());
          os << "TASession::createRunnablePlugins - Could not find parent for "
                "runnable id: "
             << p->toString();
          throw TASessionException(os.str());
        }
        // todo: handle this case too
        ASSERT(parent != 0);
        RunnablePluginInstances::iterator i =
            _runnablePluginInstances.find(*parent);
        ManagedPtr<PluginInstance<Runnable> > rp;
        if (i == _runnablePluginInstances.end()) {
          rp = (_document.getSessionPluginTree()
                    .getPlugin<Runnable, Node::NodeType::RUNNABLE>(*parent))
                   .release();
          _runnablePluginInstances.insert(
              RunnablePluginInstances::value_type(*parent, rp));
        }
      }

      // for each runnable build its own commission object
      if (_document.hasDefaultCommission()) {
        const UniqueId* id = _document.getDefaultCommissionId();
        ASSERT(id != 0);
        _defCommissionPlugin =
            getGlobalPluginTree()
                .getPlugin<Commission, Node::NodeType::COMMISSION>(*id);
      }

      // for each runnable build its own commission object
      if (_document.hasDefaultSlippage()) {
        const UniqueId* id = _document.getDefaultSlippageId();
        ASSERT(id != 0);
        _defSlippagePlugin =
            getGlobalPluginTree().getPlugin<Slippage, Node::NodeType::SLIPPAGE>(
                *id);
      }
    } catch (const IdNotFoundException& e) {
      LOG1(log_error, getSessionId().toString(),
           "IdNotFoundException (rethrowing): " << e.message());
      throw;
    } catch (...) {
      LOG1(log_error, getSessionId().toString(),
           "Uknown exception, re-throwing");
      throw;
    }
  }

  void createRunnable(const UniqueId* p) {
    ASSERT(p != 0);
    LOG1(log_info, getSessionId().toString(),
         "creating runnable: " << p->toString());
    const UniqueId* parent = _document.getSessionPluginTree().parent(*p);
    // todo: handle this case too
    ASSERT(parent != 0);
    size_t k = _runnablePluginInstances.size();
    RunnablePluginInstances::iterator i =
        _runnablePluginInstances.find(*parent);
    ManagedPtr<PluginInstance<Runnable> > rp;
    if (i != _runnablePluginInstances.end())
      rp = i->second;
    else {
      assert(false);
    }

    ManagedPtr<Runnable> runnable(
        (*rp)->get(*p, _document.getRunnablesStrings()));
    _runnables.push_back(runnable);

    DataInfoIterator* dii = 0;
    DataIteratorsMap::iterator it = _dataInfoIterators.find(*p);

    // get the same data iterator for instances of the same system (based on
    // system id)
    if (it == _dataInfoIterators.end()) {
      dii = new SimpleDataInfoIterator(_defDataSource.getDataSource(),
                                       _defSymbolsSource.makeIterator());
      _dataInfoIterators.insert(DataIteratorsMap::value_type(*p, dii));
    } else
      dii = it->second.get();

    // now create the commission object (if any)
    // each runnable gets its own instance of a commission object
    ManagedPtr<Commission> commission;
    if (_defCommissionPlugin.get() != 0) {
      commission = ((*_defCommissionPlugin)
                        ->get(*_document.getDefaultCommissionId(),
                              _document.defaultCommissionStrings()));
      _commissions.push_back(commission);
    }

    // now create the slippage object (if any)
    // each runnable gets its own instance of a slippage object
    ManagedPtr<Slippage> slippage;
    if (_defSlippagePlugin.get() != 0) {
      slippage = ((*_defSlippagePlugin)
                      ->get(*_document.getDefaultSlippageId(),
                            _document.defaultSlippageStrings()));
      _slippages.push_back(slippage);
    }

    _session.addRunnable(
        runnable.get(), _params->getPositionsVector(), /*error sink*/ this, dii,
        /*signal handler*/ &_defSignalHandler,
        /* runnable status receiver*/ this, slippage.get(), commission.get(),
        _chartManager, _document.getExplicitTrades(runnable->id()));
  }

  // this creates the runnables and their associated commissions, slippage etc
  void createRunnables() {
    size_t threads = _document.getRuntimeParams().getThreads();
    ThreadAlgorithm ta = _document.getRuntimeParams().getThreadAlgorithm();

    if (ta.oneSystemInMultipleThreds()) {
      if (_document.runnablesCount() >= threads) {
        for (const UniqueId* p = _document.getFirstRunnableId(); p != 0;
             p = _document.getNextRunnableId())
          createRunnable(p);
      } else {
        const UniqueId* p = 0;
        for (unsigned long instances = 0; instances < threads;
             ++instances, p = _document.getNextRunnableId()) {
          if (p == 0) p = _document.getFirstRunnableId();

          createRunnable(p);
        }
      }
    } else {
      for (const UniqueId* p = _document.getFirstRunnableId(); p != 0;
           p = _document.getNextRunnableId())
        createRunnable(p);
    }
  }

  void releaseRunnables() {
    // needs to be done before releasing the plugin, as their destructor is in
    // the plugin
    _runnables.clear();
    _commissions.clear();
    _slippages.clear();
    // clear the pointers to runnables from the scheduler
    _session.resetRunnables();
  }

  void releaseRunnablePlugins() {
    _runnablePluginInstances.clear();
    delete _defCommissionPlugin.release();
    delete _defSlippagePlugin.release();
  }

  void releasePlugins() {
    releaseRunnables();
    releaseRunnablePlugins();
    _defDataSource.release();
    _defSymbolsSource.release();
    if (_document.hasDefaultSignalHandler()) _defSignalHandler.release();
  }

  void resetCounters() {
    // reset the error counters
    TAErrorSink::reset();
    _defSignalHandler.reset();
    SessionRunTimer::reset();
    RunsCounter::reset();
    _sessionTradesCount = 0;
  }

 public:
  size_t runTradesCount() const { return _params->posCount(); }
  size_t sessionTradesCount() const {
    return _sessionTradesCount + _params->posCount();
  }

  // count: the number of times it will run before releasing the plugins
  // this mode it will wait for restart notification
  void start(PositionsVector& pos) throw(StartingActiveSessionException,
                                         TASessionException) {
    LOG1(log_info, getSessionId().toString(), "session starting");
    Lock lock(_mx);
    _params = new SessionParams(pos);
    // start is not re-entrant
    if (_status != READY) throw StartingActiveSessionException();
    try {
      std::vector<std::string> errors;
      std::ostringstream o;
      if (_document.hasDefaultDataSource() == 0)
        errors.push_back("No default data source");

      if (_document.hasDefaultSymbolsSource() == 0)
        errors.push_back("No default symbols source");

      if (_document.runnablesCount() == 0)
        errors.push_back("No runnables to run");

      if (errors.size() > 0) {
        std::string str;
        for (size_t n = 0; n < errors.size(); n++) str += errors[n] + "\n";

        throw TASessionException(str);
      }

      LOG1(log_info, getSessionId().toString(), "creating data source context")
      _defDataSource.create(*_document.getDefaultDataSourceId(),
                            _document.defaultDataSourceStrings());
      _defSymbolsSource.create(*_document.getDefaultSymbolsSourceId(),
                               _document.defaultSymbolsSourceStrings());
      if (_document.hasDefaultSignalHandler())
        _defSignalHandler.create(*_document.getDefaultSignalHandlerId(),
                                 _document.defaultSignalHandlerStrings());
      LOG1(log_info, getSessionId().toString(), "creating runnable plugins")
      createRunnablePlugins();
      LOG1(log_info, getSessionId().toString(),
           "TASession::start - creating runnables")
      createRunnables();

      resetCounters();

      DateTimeRangePtr range = _document.getRuntimeParams().getRange();
      setStatusRunning();
      notifySessionStarted(range);
      _session.run(
          true, _document.getRuntimeParams().getThreads(),
          _document.getRuntimeParams().getThreadAlgorithm().processorAffinity(),
          range, _document.getRuntimeParams().startTradesDateTime());
      LOG1(log_info, getSessionId().toString(), "session ended");
    } catch (const PluginMethodException& e) {
      setStatusReady();
      std::ostringstream o;
      o << "Can't run session - plugin exception: " << e.message();
      throw TASessionException(o.str());
    } catch (const PluginInstanceException& e) {
      setStatusReady();
      std::ostringstream o;
      o << "Can't run session - plugin exception: " << e.message();
      throw TASessionException(o.str());
    }
  }

  RuntimeStatus getStatus() const { return _status; }

  // from Running
  bool isRunning() const { return getStatus() != READY; }

  void cancel() {
    Lock lock(_mx);
    NonRecursiveLock statusChangeLock(_mxStatusChange);
    setStatusCanceling();
    // if running, cancel the current run (the release will happen on the
    // "ended" event)

    notifySessionCanceled();

    if (_session.isRunning())
      _session.cancelAsync();
    else {
      // if not active run, release plugins
      notifySessionEnded();
      setStatusReady();
      statusChangeLock.unlock();
      releasePlugins();
    }
  }

  //****************
  // RunStatusEventHandler virtual methods
  // they do some local processing as well as are forwarded to the next receiver
  virtual void runStarted() {
    Lock lock(_mx);
    NonRecursiveLock statusChangeLock(_mxStatusChange);
    notifyRunStarted();
  }

  virtual void runCanceled() {
    Lock lock(_mx);
    NonRecursiveLock statusChangeLock(_mxStatusChange);
    setStatusCanceling();
    notifyRunCanceled();
  }
  virtual void runEnded() {
    Lock lock(_mx);
    NonRecursiveLock statusChangeLock(_mxStatusChange);
    // the session trade count is now updated
    SessionRunTimer::stopRun();
    notifyRunEnded();
    notifySessionEnded();
    releasePlugins();
    setStatusReady();
    statusChangeLock.unlock();
    releaseRunnables();
  }

  bool exportPositionsCSV(std::ostream& os) const {
    return _params->exportPositionsCSV(os);
  }

  void sendPositions(PositionHandler& pr, bool& cancel) {
    _params->sendPositions(pr, cancel);
  }

  unsigned __int64 defSymbolsCount() const
      throw(SymbolsSourceNotAvailableException) {
    return _defSymbolsSource.symbolsCount();
  }
};