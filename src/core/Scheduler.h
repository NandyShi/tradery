/*
Copyright (C) 2018 Adrian Michel
http://www.amichel.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#pragma once

#include "structuredexception.h"
#include "moremiscwin.h"
#include <log.h>

/** @file
 *  \brief Contains all scheduler related classes
 */
extern DataManager* _dataManager;

class SynchronizedFlag {
 private:
  bool _f;
  mutable Mutex _mutex;

 public:
  SynchronizedFlag() : _f(false) {}

  SynchronizedFlag(bool f) : _f(f) {}

  void set(bool f) {
    Lock lock(_mutex);

    _f = f;
  }

  bool get() const {
    Lock lock(_mutex);

    return _f;
  }
};

/**
 * This class contains all the information needed to run a Runnable:
 * - the runnable itself
 * - an iterator pointing to the symbol in list of symbols on which to run the
 * Runnable
 * - the default positions container where the generated positions will be
 * stored
 * - the error sink object, where run time error events will be sent
 * - slippage and commission algorithms
 * - an signal handler, which will receive signals generated during the run (if
 * any)
 *
 * In order to run a Runnable, the Scheduler creates a thread (or reuses an
 * existing one) and calls the method RunnableInfo::run which intializes the
 * Runnable with the necessary information, starts its execution and calls the
 * cleanup methods when the execution is over. It also captures the runtime
 * errors triggered by the runnable, which are then sent to the ErrorSink.
 */
class RunnableInfo {
  OBJ_COUNTER(RunnableInfo)
 private:
  /**
   * the runnable.
   * TODO: Note that there is one instance, so when running multiple threads, we
   * won't be able to run the same runnable on multiple symbols at the same time
   * - fix this
   */
  Runnable* _runnable;

  /**
   * The list of symbols on which the runnable should be run
   */
  DataInfoIterator* _symbols;
  /**
   * The list of cumulated positions generated by this runnable on all the
   * symbols
   */
  PositionsVector& _pos;
  size_t _crtSymbol;
  ErrorEventSink* _es;
  Slippage* _slippage;
  Commission* _commission;
  std::vector<SignalHandler*> _signalHandlers;
  RunnableRunInfoHandler* _runnableRunInfoHandler;
  chart::ChartManager* _chartManager;

  const ExplicitTrades* _explicitTrades;

 private:
  void addErrorEvent(ErrorEvent e) { _es->push(e); }

  /**
   *
   * @return
   */
  const std::string& getRunnableName() const { return _runnable->name(); }

 public:
  /**
   * Constructor - takes all the info needed by the Runnable to run as arguments
   *
   * @param runnable   pointer to a Runnable
   * @param symbols    Iterator on a list of symbols, pointing to the current
   * symbol to run the runnable on
   * @param pos        A collection of positions where to store the positions
   * generated during back-test run
   * @param es         An error sink, which will receive run time errors
   * triggered by the Runnable
   * @param slippage   Slippage algorithm
   * @param commission Commission algorithm
   * @param signalHandler
   *                   signal handler which will receive the signals generated
   * by the runnable (if any) during the run.
   * @param printStatus
   * @see PositionsPtrList
   * @see ErrorEventSink
   * @see Slippage
   * @see Commission
   * @see AlertHandler
   */
  RunnableInfo(Runnable* runnable, DataInfoIterator* symbols,
               PositionsVector& pos, ErrorEventSink* es,
               SignalHandler* signalHandler,
               RunnableRunInfoHandler* runnableRunInfoHandler,
               Slippage* slippage, Commission* commission,
               chart::ChartManager* chartManager,
               const ExplicitTrades* explicitTrades)
      : _runnable(runnable),
        _symbols(symbols),
        _pos(pos),
        _es(es),
        _slippage(slippage),
        _commission(commission),
        _runnableRunInfoHandler(runnableRunInfoHandler),
        _chartManager(chartManager),
        _explicitTrades(explicitTrades) {
    assert(_symbols != 0);
    assert(_runnable != 0);
    assert(_es != 0);
    if (signalHandler != 0) _signalHandlers.push_back(signalHandler);
  }

  RunnableInfo(Runnable* runnable, DataInfoIterator* symbols,
               PositionsVector& pos, ErrorEventSink* es,
               const std::vector<SignalHandler*>& signalHandlers,
               RunnableRunInfoHandler* runnableRunInfoHandler,
               Slippage* slippage, Commission* commission,
               chart::ChartManager* chartManager,
               const ExplicitTrades* explicitTrades)
      : _runnable(runnable),
        _symbols(symbols),
        _pos(pos),
        _es(es),
        _slippage(slippage),
        _commission(commission),
        _signalHandlers(signalHandlers),
        _runnableRunInfoHandler(runnableRunInfoHandler),
        _chartManager(chartManager),
        _explicitTrades(explicitTrades) {
    assert(_symbols != 0);
    assert(_runnable != 0);
    assert(_es != 0);

    int n = _signalHandlers.size();
  }

  virtual ~RunnableInfo() {}

  /**
   * runs the Runnable on a range of the available data
   * If first initializes it with all the information such as the collection
   * of data elements on which to run it, the positions collection etc.
   *
   * It loads as much data as is specified by the range parameter. The range
   * parameter can be any type of range, time, bars indexes, a set of smaller
   * ranges etc as it is a polymorphic class
   *
   * This method also captures all runtime errors triggered by the Runnable and
   * sends them to the ErrroEventSink
   *
   * The cancelStat is reference to a flag that indicates whether the Runnable
   * should cancel its run. This flag is set if a cancel command is given by the
   * user code
   *
   * @param cancelState
   *               reference to flag indicating whether the Runnable should
   * abort
   * @param range  The range of data on which to run the Runnable
   * @return
   * @exception DataSourceException
   */
  bool run(const std::string& threadName, const SynchronizedFlag& cancelState,
           DateTimeRangePtr range,
           DateTime startTradesDateTime) throw(DataSourceException) {
    bool exitCall = false;
    do {
      // called before the first symbol, to signal that a new simulation session
      // is starting if false, then stop running this runnable
      if (!_runnable->begin()) break;

      try {
        for (DataInfoConstPtr si = _symbols->getNext(); si.get() != 0;
             si = _symbols->getNext()) {
          Timer t;
          chart::Chart* chart = 0;

          //        std::auto_ptr< const SymbolInfo > psi( si );
          // creating an empty  local list of positions, which will contain
          // positions for the current run of the runnable.
          PositionsContainer* pc = _pos.getNewPositionsContainer();
          // creating a positions object, which will be passed to the runnable.
          // This positions object contains a pointer to the positions list
          // object
          PositionsManagerImpl pos(pc, startTradesDateTime,
                                   PosInfinityDateTime(), _slippage,
                                   _commission);

          pos.registerSignalHandlers(_signalHandlers);

          // get the pointer to the bars object

          try {
            double dataDuration = 0;
            double runnableDuration = 0;
            unsigned __int64 dataSize = 0;
            try {
              // TODO:
              // this is a hack - normally data should be handled the same way,
              // regardless of where it's coming from. the problem is that when
              // it's requested from the DataManager, it comes as ManagedPtr,
              // which has a RefCountable used by the cache, when data comes
              // directly from the SymbolInfo, it comes as a pointer. Unify
              // these two!!!!
              /*          if( si->hasData() )
                                {
                                      _runnable -> init( si->getData(), &pos );
                                      // call the preRun method - give the
                 runnable a chance to stop before it starts if ( _runnable ->
                 init( psi->symbol() ) )
                                      {
                                        // run the runnable
                                        _runnable ->run();
                                        _runnable->cleanup();
                                      }
                                }
                                else
        */
              {
                Timer dataTimer;
                BarsPtr data = si->dataSource()
                                   ->getData(si.get(), range)
                                   ->getDataCollection();
                if (data.get() != 0) dataSize = data->size();

                if (data->hasInvalidData()) {
                  // we got here because we are in data warning mode (otherwise
                  // there would have been an exception)
                  ErrorEvent ee(
                      ErrorEvent::Types::INVALID_DATA,
                      ErrorEvent::Category::warning, getRunnableName(),
                      data->getInvalidDataAsString(), si->symbol().symbol());
                  addErrorEvent(ee);
                }

                if (_explicitTrades != 0) {
                  // now process explicit trades that are before the
                  // startTradesDateTime The way things work: if a
                  // startTradesDate is specified, all explicit trades before
                  // that date are automatically generated, and the system
                  // generates trades after that date We use a new position
                  // manager with no start date set, as the date will be
                  // controlled from within the toPositions todo: change this,
                  // everything should be controlled from the manager, so this
                  // manager would have a different range
                  PositionsManagerImpl pos1(pc, NegInfinityDateTime(),
                                            startTradesDateTime);
                  pos1.setSystemName("explicit trade");

                  _explicitTrades->toPositions(Positions(&pos1), si->symbol(),
                                               data, NegInfinityDateTime(),
                                               startTradesDateTime);
                }

                dataDuration = dataTimer.elapsed();

                if (false) {
                  LOG(log_info, threadName << " : " << _runnable->name()
                                           << " on \""
                                           << si->symbol().symbol());
                }
                Timer runnableTimer;
                bool wasCleanup = false;
                try {
                  chart = _chartManager->getChart(si->symbol().symbol());
                  if (chart == 0) {
                    LOG(log_info, "RunnableInfo::run - chartHandler is 0");
                  }
                  // if the symbol must not be charted, a NullChartHandler is
                  // returned, so it will never return 0
                  assert(chart != 0);
                  // init the chart handler
                  // new - adding a chart handler, so user code can generate
                  // charts
                  chart->init(data, pc);

                  pos.setSystemName(_runnable->name());
                  pos.setSystemId(_runnable->getUserString());

                  // init the runnable - set the default bars, positions, data
                  // manager and series manager
                  //  todo: if chartHandler is 0, pass a default chart handler
                  //  that doesn't do anything
                  _runnable->init(data.get(), &pos, chart, _explicitTrades);
                  // call the preRun method - give the runnable a chance to stop
                  // before it starts
                  if (_runnable->init(si->symbol().symbol())) {
                    // run the runnable
                    _runnable->run();
                    // mark that we are entering cleanup, in case exceptions are
                    // thrown there
                    wasCleanup = true;
                    _runnable->cleanup();
                  }
                } catch (...) {
                  // catching all exceptions so we can do cleanup first
                  // this test is so we don't get into an infinite loop when
                  // cleanup itself is throwing an exception
                  if (!wasCleanup) {
                    // mark that we are calling cleanup
                    wasCleanup = true;
                    _runnable->cleanup();
                  }
                  // now rethrow to handle the actual exception
                  throw;
                }
                runnableDuration = runnableTimer.elapsed();
              }
              // we are here because there are no errors, so send the status
              if (_runnableRunInfoHandler != 0)
                // there were no errors
                _runnableRunInfoHandler->status(RunnableRunInfo(
                    _runnable->name(), si->symbol().symbol(), dataDuration,
                    runnableDuration, dataSize, false, threadName));
            } catch (const ExitRunnableException&) {
              exitCall = true;
              throw;
            } catch (...) {
              LOG(log_info, "Runtime error \"" << _runnable->name()
                                               << "\" on \""
                                               << si->symbol().symbol());
              // first catch all exceptions to signal the status, and diable the
              // chart
              if (_runnableRunInfoHandler != 0)
                // there were errors
                _runnableRunInfoHandler->status(RunnableRunInfo(
                    _runnable->name(), si->symbol().symbol(), dataDuration,
                    runnableDuration, dataSize, true, threadName));

              // only stop charting if there were real errors, if it's an exit,
              // then still chart
              if (chart != 0 && !exitCall)
                chart->setError(
                    "Trading system runtime error - no chart has been "
                    "generated for this symbol");
              // then re-throw for handling
              throw;
            }
          } catch (const BarException& e) {
            LOG(log_error, " - caught BarException, creating event");
            ErrorEvent ee(ErrorEvent::Types::INVALID_DATA,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            LOG(log_debug, " - adding event");
            addErrorEvent(ee);
            LOG(log_debug, " - added event");
          } catch (const DataSourceException& e) {
            // TODO: there are a multitude of data source exceptions - fix this
            std::wostringstream o;
            //          o << _T( "Datasource \"" ) << e.getDataSourceName() <<
            //          _T( "\" error: " ) << e.message();
            ErrorEvent ee(ErrorEvent::Types::DATA_SOURCE_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const GeneralSystemException& e) {
            ErrorEvent ee(ErrorEvent::Types::GENERAL_SYSTEM_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const PositionIdNotFoundException& e) {
            ErrorEvent ee(ErrorEvent::Types::POSITION_ID_NOT_FOUND_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const SystemException& e) {
            ErrorEvent ee(ErrorEvent::Types::SYSTEM_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const BarIndexOutOfRangeException& e) {
            ErrorEvent ee(ErrorEvent::Types::BAR_INDEX_OUT_OF_RANGE_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const InvalidLimitPriceException& e) {
            ErrorEvent ee(ErrorEvent::Types::INVALID_LIMIT_PRICE_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const InvalidStopPriceException& e) {
            ErrorEvent ee(ErrorEvent::Types::INVALID_STOP_PRICE_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const SeriesIndexOutOfRangeException& e) {
            ErrorEvent ee(ErrorEvent::Types::SERIES_INDEX_OUT_OF_RANGE_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const TimeSeriesIndexOutOfRangeException& e) {
            ErrorEvent ee(
                ErrorEvent::Types::TIME_SERIES_INDEX_OUT_OF_RANGE_ERROR,
                ErrorEvent::Category::error, getRunnableName(), e.message(),
                si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const SynchronizedSeriesIndexOutOfRangeException& e) {
            ErrorEvent ee(
                ErrorEvent::Types::SYNCHRONIZED_SERIES_INDEX_OUT_OF_RANGE_ERROR,
                ErrorEvent::Category::error, getRunnableName(), e.message(),
                si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const CoveringLongPositionException& e) {
            ErrorEvent ee(ErrorEvent::Types::COVERING_LONG_POSITION_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const SellingShortPositionException& e) {
            ErrorEvent ee(ErrorEvent::Types::SELLING_SHORT_POSITION_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const ClosingAlreadyClosedPositionException& e) {
            ErrorEvent ee(
                ErrorEvent::Types::CLOSING_ALREADY_CLOSED_POSITION_ERROR,
                ErrorEvent::Category::error, getRunnableName(), e.message(),
                si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const OperationOnUnequalSizeSeriesException& e) {
            ErrorEvent ee(
                ErrorEvent::Types::OPERATION_ON_UNEQUAL_SIZE_SERIES_ERROR,
                ErrorEvent::Category::error, getRunnableName(), e.message(),
                si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const DivideByZeroException& e) {
            // dummy division which will result in a NaN (not a number) result.
            double x = 100.0 / 50.0;
            ErrorEvent ee(ErrorEvent::Types::FLOATING_POINT_DIVIDE_BY_0_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const AccessViolationException& e) {
            ErrorEvent ee(ErrorEvent::Types::ACCESS_VIOLATION_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());
            addErrorEvent(ee);
          } catch (const SignalHandlerException& e) {
            ErrorEvent ee(ErrorEvent::Types::SIGNAL_HANDLER_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.name() + ": " + e.message(), "");

            addErrorEvent(ee);
          } catch (const InvalidIndexForOperationException& e) {
            ErrorEvent ee(
                ErrorEvent::Types::INVALID_INDEX_FOR_OPERATION_EXCEPTION,
                ErrorEvent::Category::error, getRunnableName(), e.message(),
                si->symbol().symbol());

            addErrorEvent(ee);
          } catch (const SeriesSynchronizerException& e) {
            ErrorEvent ee(ErrorEvent::Types::SERIES_SYNCHRONIZER_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());

            addErrorEvent(ee);
          } catch (const chart::ChartException& e) {
            ErrorEvent ee(ErrorEvent::Types::CHART_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());

            addErrorEvent(ee);
          } catch (const OperationOnSeriesSyncedToDifferentSynchronizers& e) {
            ErrorEvent ee(
                ErrorEvent::Types::
                    OPERATION_ON_SERIES_SYNCED_TO_DIFFERENT_SYNCHRONIZERS_ERROR,
                ErrorEvent::Category::error, getRunnableName(), e.message(),
                si->symbol().symbol());

            addErrorEvent(ee);
          } catch (const PositionCloseOperationOnOpenPositionException& e) {
            ErrorEvent ee(ErrorEvent::Types::
                              POSITION_CLOSE_OPERATION_ON_OPEN_POSITION_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());

            addErrorEvent(ee);
          } catch (const PositionZeroPriceException& e) {
            ErrorEvent ee(ErrorEvent::Types::POSITION_ZERO_PRICE_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());

            addErrorEvent(ee);
          } catch (const OperationNotAllowedOnSynchronizedseries& e) {
            ErrorEvent ee(
                ErrorEvent::Types::
                    OPERATION_NOT_ALLOWED_ON_SYNCHRONIZED_SERIES_ERROR,
                ErrorEvent::Category::error, getRunnableName(), e.message(),
                si->symbol().symbol());

            addErrorEvent(ee);
          } catch (const ExitRunnableException& e) {
            ErrorEvent ee(ErrorEvent::Types::EXIT_STATMENT_CALL,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());

            addErrorEvent(ee);
            return false;
          } catch (const InvalidBarsCollectionException& e) {
            ErrorEvent ee(ErrorEvent::Types::INVALID_BARS_COLLECTION_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());

            addErrorEvent(ee);
          } catch (const ArrayIndexNotFoundException& e) {
            ErrorEvent ee(ErrorEvent::Types::ARRAY_INDEX_NOT_FOUND_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());

            addErrorEvent(ee);
          } catch (const DictionaryKeyNotFoundException& e) {
            ErrorEvent ee(ErrorEvent::Types::DICTIONARY_KEY_NOT_FOUND_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());

            addErrorEvent(ee);
          } catch (const InvalidPositionException& e) {
            ErrorEvent ee(ErrorEvent::Types::INVALID_POSITION_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          e.message(), si->symbol().symbol());

            addErrorEvent(ee);
          } catch (const ClosingPostionOnDifferentSymbolException& e) {
            ErrorEvent ee(
                ErrorEvent::Types::CLOSING_POSITION_ON_DIFFERENT_SYMBOL_ERROR,
                ErrorEvent::Category::error, getRunnableName(), e.message(),
                si->symbol().symbol());

            addErrorEvent(ee);
          } catch (...) {
            // catch any other unhandled exceptions
            ErrorEvent ee(ErrorEvent::Types::UNKNOWN_APPLICATION_ERROR,
                          ErrorEvent::Category::error, getRunnableName(),
                          "Unknown error", si->symbol().symbol());
            //          tsprint( ee.toString() + _T( "\n" ), std::cout );
            addErrorEvent(ee);
          }
          // exit if cancel signaled
          if (cancelState.get()) return false;
        }
      } catch (const DataInfoException&) {
        ErrorEvent ee(ErrorEvent::Types::DATA_INFO_ERROR,
                      ErrorEvent::Category::error, getRunnableName(),
                      "Data info invalid, possibly a null symbol", "");
      }
    }
    // repeats the loop until the runnable returns true, indicating that it has
    // finished its work
    while (_runnable->again());
    return true;
  }
};

/**
 * A collection of RunnableInfo's implemented as a vector to pointers to
 * RunnableInfo instances
 *
 * This is used by the Scheduler to store RunnableInfo instances created when
 * the user code adds new Runnable instances to the Scheduler
 *
 * A RunnableInfoList stores a reference to a "current" RunnableInfo, and has
 * a getNext method, both of which are used to iterate through the list
 * of all RunnableInfo instances and run the associated Runnable.
 *
 * This class is thread safe, in that different threads can call its methods
 * simultaneously and the access to data will be safely serialized. This is
 * necessary as each thread will have to call into this class to get the next
 * RunnableInfo that has the info for the Runnable to be run.
 *
 * @see PVector
 * @see RunnableInfo
 * @see Scheduler
 */
class RunnableInfoList : public PtrVector<RunnableInfo> {
  OBJ_COUNTER(RunnableInfoList)
 private:
  unsigned int _crt;
  mutable Mutex _mutex;
  const std::string _name;

 public:
  /**
   * Constructor - takes the name
   *
   * Also resets the "current" value to point to the first element in the list
   *
   * @param name   The name
   */
  RunnableInfoList(const std::string& name) : _crt(0), _name(name) {}

  void reset() {
    Lock lock(_mutex);
    _crt = 0;
    ;
  }

  /**
   * Returns the next available RunnableInfo and increments the "current" value
   * to point to the following one.
   *
   * if there are no more RunnableInfo in the collection, return null.
   *
   * @return A pointer to a RunnableInfo or 0 if no more available
   */
  RunnableInfo* getNext() {
    Lock lock(_mutex);

    RunnableInfo* p = _crt < size() ? at(_crt++) : 0;
    return p;
  }
};

/**
 * This implements a thread of execution for Runnable instances.
 *
 * Each new thread created by the Scheduler will have a RunnableThread object
 * associated
 *
 * The thread runs in the operator() method of this object.
 *
 * A RunnableThread has
 * - a reference to a RunnableInfoList where it will get the next
 * RunnableInfo to run.
 * - the name of the thread
 * - the range on which to run all Runnable instances in the current thread
 * - a ThreadInitializer, used to do a one time thread initialization.
 *
 * @see Scheduler
 * @see RunnableInfoList
 * @see SynchronizedFlag
 * @see Range
 */
class RunnableThread {
 private:
  RunnableInfoList& _runnables;
  const unsigned int _index;
  const std::string _name;
  const SynchronizedFlag& _cancelState;
  DateTimeRangePtr _range;
  const DateTime _startTradesDateTime;
  ThreadInitializer* _threadInitializer;
  const bool _cpuAffinity;

 public:
  /**
   * Constructor - takes all parameters needed to intialize the object as
   * parameters
   *
   * @param systems Reference to the RunnableInfoList object
   * @param name    The name of the thread
   * @param cancelState
   *                Reference to the cancelState flag indicating whether to
   * abort or not
   * @param range   Pointer to a range object
   * @param threadInitializer
   *                pointer to a thread initializer
   * @see ThreadInitializer
   * @see Range
   * @see SynchronizedFlag
   * @see RunnableInfoList
   */
  RunnableThread(RunnableInfoList& systems, unsigned int index,
                 const std::string& name, const SynchronizedFlag& cancelState,
                 DateTimeRangePtr range, ThreadInitializer* threadInitializer,
                 bool cpuAffinity, DateTime startTradesDateTime)
      : _runnables(systems),
        _index(index),
        _name(name),
        _cancelState(cancelState),
        _range(range),
        _threadInitializer(threadInitializer),
        _cpuAffinity(cpuAffinity),
        _startTradesDateTime(startTradesDateTime) {}

  virtual ~RunnableThread() {}

  /**
   * operator() - called when the new thread starts/
   *
   * This function gets called when the thread starts. It will iterate through
   * the list of RunnableInfo until the iterator points to the end of the list.
   *
   * For each RunnableInfo in the list it will run the associated Runnable.
   *
   * Multiple threads will iterate through the same list, so each thread will
   * get to run only a subset of all the RunnableInfo instances in the list.
   *
   * Because of this algorithm, all threads created by a Scheduler will be busy
   * until the itertor points to the end of the list, meaning that all the
   * Runnable have been run.
   *
   * In order to run one runnable in multiple threads, create multiple instances
   * of the same runnable and use one symbols list iterator for all of them
   *
   * @see The thread function.
   * @see This operator gets called when the thread starts. It will iterate
   * through the
   * @see list of RunnableInfo and for each RunnableInfo will run the associated
   * Runnable.
   * @see Multiple threads will iterate through the same lists
   */
  void operator()() {
    if (_cpuAffinity) setCurrentThreadIdealProcessor(_index);
    if (_threadInitializer != 0) _threadInitializer->init();
    StructuredException::install();
    bool f = true;

    for (RunnableInfo* si = _runnables.getNext(); si != 0 && f;
         si = _runnables.getNext()) {
      f = si->run(_name, _cancelState, _range, _startTradesDateTime);
    }

    if (_threadInitializer != 0) _threadInitializer->uninit();
  }
};

/**
 * Definition of a ThreadVector
 *
 * @see RunnableThread
 * @see PtrVector
 */
typedef PtrVector<RunnableThread> ThreadVector;
/**
 * Prototype for the actual thread function that will be called when the
 * Runnable are run in asyncronous mode
 *
 * @param param  Pointer to an arbitrary parameter to be passed to the thread.
 * In our case this parameter will be a pointer to a AsynchRunInfo object
 * @see Scheduler
 */
void thread_func(void* param);

class SchedulerImpl;

/**
 * contains the information needed by the thread function when the Scheduler
 * nees to run the Runnable asynchronously, meaning the Scheduler run method
 * will return immediately without waiting for all Runnable to complete their
 * runs
 *
 * The information contains the Scheduler instance that is running the Runnable,
 * and the range on which it is running them
 *
 * @see Scheduler
 * @see thread_func
 */
class AsynchRunInfo {
 private:
  SchedulerImpl* _scheduler;
  DateTimeRangePtr _range;
  const DateTime _startTradesDateTime;
  unsigned long _threads;
  bool _cpuAffinity;

 private:
  AsynchRunInfo(const AsynchRunInfo& ari) {}

  const AsynchRunInfo& operator=(const AsynchRunInfo& ari) { return *this; }

 public:
  /**
   * Constructor - takes the scheduler object as parameter and sets the range to
   * "all" (0)
   *
   * @see Scheduler
   */
  AsynchRunInfo(SchedulerImpl* scheduler) : _scheduler(scheduler), _range(0) {}

  /**
   * Constructor - takes the scheduler object as parameter and a range
   *
   * @see Scheduler
   * @see Range
   */
  AsynchRunInfo(SchedulerImpl* scheduler, unsigned long threads,
                bool cpuAffinity, DateTimeRangePtr range,
                DateTime startTradesDateTime)
      : _scheduler(scheduler),
        _range(range),
        _threads(threads),
        _cpuAffinity(cpuAffinity),
        _startTradesDateTime(startTradesDateTime) {}

  /**
   * Returns the Scheduler
   *
   * @return the Scheduler
   */
  SchedulerImpl* getScheduler() { return _scheduler; }

  /**
   * returns the Range
   *
   * @return the Range
   */
  DateTimeRangePtr getRange() const { return _range; }

  unsigned long threads() const { return _threads; }
  bool getCPUAffinity() const { return _cpuAffinity; }
  DateTime startTradesDateTime() const { return _startTradesDateTime; }
};

/**
 * The Scheduler implementation
 *
 * It coordinates the running of the Runnables in the specified number of
 * threads
 */
class SchedulerImpl : public Scheduler {
 private:
  RunnableInfoList _runnables;
  // this is just so the thread object be destroyed at the end

  mutable Mutex _mutex1;
  mutable NonRecursiveMutex _mutex2;
  mutable Condition _condition2;

  SynchronizedFlag _cancelState;
  SynchronizedFlag _running;
  ThreadInitializer* _threadInitializer;
  RunEventHandler* _runEventHandler;

  // a set of all signal handlers for the session. There are no duplicates here,
  // so if each runnable sends signals to the same signal handler, there will
  // only be one in this set. This is used by the scheduler to signal the start
  // and end of a session to all signal handlers for the session, without the
  // danger of sending multiple notifications to the same handler
  std::set<SignalHandler*> _signalHandlersSet;
  std::set<ErrorEventSink*> _errorSinkSet;

 public:
  /**
   * Constructor - takes the number of threads and a printStatus as parameters
   *
   * The number of threads indicates in how many threads all the Runnables will
   * be run.
   *
   * The printstatus is a debug feature - in command line mode it will print out
   * to the console the status of the Scheduler
   *
   * @param nbThreads The number of threads
   * @param printStatus
   *                  The print status
   */
  SchedulerImpl(RunEventHandler* runEventHandler = 0)
      : _runnables("Systems"),
        _threadInitializer(0),
        _runEventHandler(runEventHandler) {}

  virtual ~SchedulerImpl() {}

  /**
   * Sets the ThreadInitializer that will be used to initialize each of the
   * created threads
   *
   * @param threadInitializer
   *               pointer to a thread initializer object
   */
  virtual void setThreadInitializer(ThreadInitializer* threadInitializer) {
    _threadInitializer = threadInitializer;
  }

  /**
   * Adds a Runnable to the list of Runnables that will be run by the Scheduler
   *
   * Each Runnable is associated with a number of parameters:
   * - SymbolsListIterator - the iterator on the list of symbols will be run on
   * - PositionsContainer - a container of positions in which will the Runnable
   * will store the created positions
   * - ErrorEventSink - an even sink that will receive the runtime error events
   * - Slippage - the slippage
   * - Commission - the commission
   * - AlertHandler - the signal handler that will receive the signals triggered
   * by the Runnable
   *
   * @param runnable   The runnable to be added
   * @param s          the iterators on the list of symbols
   * @param pos        the positions container
   * @param es         the error event sink
   * @param slippage   the slippage
   * @param commission the commission
   * @param signalHandler
   *                   the signal handler
   * @see Runnable
   * @see SymbolsListIterator
   * @see PositionsContainer
   * @see ErrorEventSink
   * @see Slippage
   * @see Commission
   * @see AlertHandler
   */
  void addRunnable(Runnable* runnable, DataInfoIterator* s,
                   PositionsVector& pos, ErrorEventSink* es,
                   SignalHandler* signalHandler = 0,
                   RunnableRunInfoHandler* runnableRunInfoHandler = 0,
                   Slippage* slippage = 0, Commission* commission = 0,
                   chart::ChartManager* chartManager = 0,
                   const tradery::ExplicitTrades* explicitTrades = 0) {
    try {
      _runnables.push_back(new RunnableInfo(
          runnable, s, pos, es, signalHandler, runnableRunInfoHandler, slippage,
          commission, chartManager, explicitTrades));
      _signalHandlersSet.insert(signalHandler);
      _errorSinkSet.insert(es);
    } catch (const std::bad_cast&) {
      // TODO: throw an exception for the user to tell him he cannot derive from
      // PositionsContainer
      assert(false);
    }
  }

  void addRunnable(Runnable* runnable, DataInfoIterator* s,
                   PositionsVector& pos, ErrorEventSink* es,
                   const std::vector<SignalHandler*>& signalHandlers,
                   RunnableRunInfoHandler* runnableRunInfoHandler = 0,
                   Slippage* slippage = 0, Commission* commission = 0,
                   chart::ChartManager* chartManager = 0,
                   const tradery::ExplicitTrades* explicitTrades = 0) {
    try {
      _runnables.push_back(new RunnableInfo(
          runnable, s, pos, es, signalHandlers, runnableRunInfoHandler,
          slippage, commission, chartManager, explicitTrades));
      for (size_t n = 0; n < signalHandlers.size(); n++)
        _signalHandlersSet.insert(signalHandlers[n]);
      _errorSinkSet.insert(es);
    } catch (const std::bad_cast&) {
      // TODO: throw an exception for the user to tell him he cannot derive from
      // PositionsContainer
      assert(false);
    }
  }

  void resetRunnables() { _runnables.clear(); }

  /**
   * Indicates the status running or resting of the scheduler.
   *
   * @return Returns true if it is running, false if resting
   */
  bool isRunning() const { return _running.get(); }

  /**
   * Indicates the status canceling of the Scheduler
   *
   * @return Returns true if it's canceling, false otherwise
   */
  bool isCanceling() const { return _cancelState.get(); }

  /**
   * Starts running the Runnable objects in the list of runnables
   *
   * The run can be synchronous or asynchronous, depending on the parameter
   * "asynch".
   *
   * If run synchronously, run will return only after all the Runnable have
   * completed their run If run asynchronously, run will return immediately,
   * regardless of the running status of the Runnable instances
   *
   * @param asynch indicates whether to run asynchronously (true) or
   * synchronously (false)
   * @param range  The range of data on which to run the Runnables
   */
  void run(
      bool asynch, unsigned long threads, bool cpuAffinity,
      DateTimeRangePtr range,
      DateTime startTradesDateTime) throw(SchedulerReentrantRunCallException) {
    if (isRunning()) throw SchedulerReentrantRunCallException();

    _running.set(true);
    if (asynch)
      _beginthread(thread_func, 0,
                   new AsynchRunInfo(this, threads, cpuAffinity, range,
                                     startTradesDateTime));
    else
      run(threads, cpuAffinity, range, startTradesDateTime);
  }

  /**
   * Cancels the current run synchronously, meaning that the method will return
   * only after the run has been canceled
   */
  virtual void cancelSync() {
    NonRecursiveLock lock(_mutex2);
    _cancelState.set(true);
    if (_runEventHandler != 0) _runEventHandler->runCanceled();

    while (isRunning()) _condition2.wait(lock);
  }

  /**
   * Cancels the current run asynchronously, meaning that the method will return
   * immediately, without waiting for the run to be canceled
   */
  virtual void cancelAsync() {
    _cancelState.set(true);
    if (_runEventHandler != 0) _runEventHandler->runCanceled();
  }

  void run(unsigned long threads, bool cpuAffinity, DateTimeRangePtr range,
           DateTime startTradesDateTime) {
    // synchronous run relative to the calling function
    if (_runEventHandler != 0) _runEventHandler->runStarted();

    // notify all signal handlers that the run is starting
    // signal handlers may throw exceptions too, even in start, end
    SignalHandler* sh = 0;
    bool errors = false;
    /*		try
                    {
                            for( std::set< SignalHandler* >::iterator i =
       _signalHandlersSet.begin(); i != _signalHandlersSet.end(); i++ ) (sh =
       *i)->runStarted();
                    }
                    catch( const SignalHandlerException& e )
                    {
              ErrorEvent ee( ErrorEvent::Types::SIGNAL_HANDLER_ERROR, e.name(),
       e.message(), _T("---" ) );

              for( std::set< ErrorEventSink* >::iterator i =
       _errorSinkSet.begin(); i != _errorSinkSet.end(); i++ )
                    (*i)->push( ee );
                            errors = true;
                    }
    */
    // only run if there are no errors
    if (!errors) {
      _running.set(true);
      _runnables.reset();
      boost::thread_group _threads;
      ThreadVector _threadVector;

      for (unsigned int n = 0; n < threads; n++) {
        std::ostringstream o;
        o << n;
        RunnableThread* p = new RunnableThread(
            _runnables, n, o.str(), _cancelState, range, _threadInitializer,
            cpuAffinity, startTradesDateTime);
        _threadVector.push_back(p);
        _threads.create_thread(*p);
      }
      _threads.join_all();

      _running.set(false);
      _cancelState.set(false);
      _condition2.notify_one();
    } else
      _running.set(false);
    // notify the signal handlers before signalling the end of the run, as that
    // may involve deallocating the signal handlers
    /*		try
                    {
                            for( std::set< SignalHandler* >::iterator i =
       _signalHandlersSet.begin(); i != _signalHandlersSet.end(); i++ )
                                    (*i)->runEnded();
                    }
                    catch( const SignalHandlerException& e )
                    {
              ErrorEvent ee( ErrorEvent::Types::SIGNAL_HANDLER_ERROR, e.name(),
       e.message(), _T("---" ) );

              for( std::set< ErrorEventSink* >::iterator i =
       _errorSinkSet.begin(); i != _errorSinkSet.end(); i++ )
                    (*i)->push( ee );
                            errors = true;
                    }
    */
    LOG(log_debug, "session ended");
    if (_runEventHandler != 0) _runEventHandler->runEnded();
  }
};
